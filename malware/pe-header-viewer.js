document.addEventListener('DOMContentLoaded', function() {
    const peFileUpload = document.getElementById('peFileUpload');
    const analyzePE = document.getElementById('analyzePE');
    const clearAll = document.getElementById('clearAll');
    const dosHeader = document.getElementById('dosHeader');
    const ntHeaders = document.getElementById('ntHeaders');
    const sectionHeaders = document.getElementById('sectionHeaders');

    // Analyze PE
    analyzePE.addEventListener('click', function() {
        const file = peFileUpload.files[0];
        
        if (!file) {
            alert('Please upload a PE file to analyze.');
            return;
        }

        analyzePEFile(file);
    });

    // Clear all
    clearAll.addEventListener('click', function() {
        peFileUpload.value = '';
        clearResults();
    });

    // Analyze PE file
    function analyzePEFile(file) {
        // Display file information
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('fileSize').textContent = formatFileSize(file.size);
        document.getElementById('architecture').textContent = 'Analyzing...';
        document.getElementById('subsystem').textContent = 'Analyzing...';

        // Simulate PE analysis
        setTimeout(function() {
            // In a real implementation, you would parse the PE file
            // For demonstration, we'll simulate results
            const architecture = getRandomArchitecture();
            const subsystem = getRandomSubsystem();
            const compilationTime = getRandomCompilationTime();
            const sections = getRandomSectionsCount();

            document.getElementById('architecture').textContent = architecture;
            document.getElementById('subsystem').textContent = subsystem;
            document.getElementById('compilationTime').textContent = compilationTime;
            document.getElementById('sectionsCount').textContent = sections;

            // Display import table analysis
            const importTable = getRandomImportTable();
            document.getElementById('importTable').textContent = importTable;

            // Display suspicious indicators
            const indicators = getSuspiciousIndicators(architecture, sections);
            document.getElementById('suspiciousIndicators').textContent = indicators;

            // Generate mock DOS header
            dosHeader.innerHTML = '';
            const dosFields = [
                { field: 'e_magic', offset: '0x00', value: '0x5A4D', description: 'MZ Signature' },
                { field: 'e_cblp', offset: '0x02', value: '0x0090', description: 'Bytes on last page' },
                { field: 'e_cp', offset: '0x04', value: '0x0003', description: 'Pages in file' },
                { field: 'e_crlc', offset: '0x06', value: '0x0000', description: 'Relocations' }
            ];

            dosFields.forEach(field => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${field.field}</td>
                    <td>${field.offset}</td>
                    <td>${field.value}</td>
                    <td>${field.description}</td>
                `;
                dosHeader.appendChild(row);
            });

            // Generate mock NT headers
            ntHeaders.innerHTML = '';
            const ntFields = [
                { field: 'Signature', offset: '0x00', value: '0x00004550', description: 'PE Signature' },
                { field: 'Machine', offset: '0x04', value: architecture.includes('64') ? '0x8664' : '0x014C', description: 'Target Machine' },
                { field: 'NumberOfSections', offset: '0x06', value: `0x${sections.toString(16).padStart(4, '0')}`, description: 'Section Count' },
                { field: 'TimeDateStamp', offset: '0x08', value: '0x' + Math.floor(Date.now()/1000).toString(16), description: 'Compilation Time' }
            ];

            ntFields.forEach(field => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${field.field}</td>
                    <td>${field.offset}</td>
                    <td>${field.value}</td>
                    <td>${field.description}</td>
                `;
                ntHeaders.appendChild(row);
            });

            // Generate mock section headers
            sectionHeaders.innerHTML = '';
            const sectionsData = generateMockSections(sections);
            
            sectionsData.forEach(section => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${section.name}</td>
                    <td>${section.virtualSize}</td>
                    <td>${section.virtualAddress}</td>
                    <td>${section.rawSize}</td>
                    <td>${section.rawAddress}</td>
                    <td>${section.characteristics}</td>
                `;
                sectionHeaders.appendChild(row);
            });
        }, 2000);
    }

    // Format file size
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Get random architecture
    function getRandomArchitecture() {
        const archs = ['x86 (32-bit)', 'x64 (64-bit)', 'ARM', 'ARM64'];
        return archs[Math.floor(Math.random() * archs.length)];
    }

    // Get random subsystem
    function getRandomSubsystem() {
        const subsystems = ['Windows GUI', 'Windows Console', 'Native', 'POSIX'];
        return subsystems[Math.floor(Math.random() * subsystems.length)];
    }

    // Get random compilation time
    function getRandomCompilationTime() {
        const now = new Date();
        const daysAgo = Math.floor(Math.random() * 365);
        const date = new Date(now.setDate(now.getDate() - daysAgo));
        return date.toISOString().split('T')[0];
    }

    // Get random sections count
    function getRandomSectionsCount() {
        return Math.floor(Math.random() * 8) + 3; // 3-10 sections
    }

    // Get random import table
    function getRandomImportTable() {
        const imports = ['kernel32.dll', 'user32.dll', 'advapi32.dll', 'ws2_32.dll'];
        const count = Math.floor(Math.random() * 3) + 2; // 2-4 imports
        return count + ' libraries';
    }

    // Get suspicious indicators
    function getSuspiciousIndicators(architecture, sections) {
        const indicators = [];
        if (architecture.includes('64') && sections > 5) {
            indicators.push('Large section count');
        }
        if (Math.random() > 0.7) {
            indicators.push('Writable code section');
        }
        return indicators.length > 0 ? indicators.join(', ') : 'None detected';
    }

    // Generate mock sections
    function generateMockSections(count) {
        const sections = [];
        const names = ['.text', '.data', '.rdata', '.reloc', '.rsrc'];
        
        for (let i = 0; i < Math.min(count, names.length); i++) {
            sections.push({
                name: names[i],
                virtualSize: '0x' + (Math.floor(Math.random() * 0x10000)).toString(16),
                virtualAddress: '0x' + (i * 0x1000).toString(16),
                rawSize: '0x' + (Math.floor(Math.random() * 0x10000)).toString(16),
                rawAddress: '0x' + (i * 0x200).toString(16),
                characteristics: getRandomCharacteristics()
            });
        }
        
        // Add extra sections if needed
        for (let i = sections.length; i < count; i++) {
            sections.push({
                name: `.custom${i}`,
                virtualSize: '0x' + (Math.floor(Math.random() * 0x10000)).toString(16),
                virtualAddress: '0x' + (i * 0x1000).toString(16),
                rawSize: '0x' + (Math.floor(Math.random() * 0x10000)).toString(16),
                rawAddress: '0x' + (i * 0x200).toString(16),
                characteristics: getRandomCharacteristics()
            });
        }
        
        return sections;
    }

    // Get random characteristics
    function getRandomCharacteristics() {
        const chars = ['Read', 'Write', 'Execute', 'Shared'];
        const selected = [];
        for (let i = 0; i < 2; i++) {
            const idx = Math.floor(Math.random() * chars.length);
            if (!selected.includes(chars[idx])) {
                selected.push(chars[idx]);
            }
        }
        return selected.join('|');
    }

    // Clear results
    function clearResults() {
        document.getElementById('fileName').textContent = '-';
        document.getElementById('fileSize').textContent = '-';
        document.getElementById('architecture').textContent = '-';
        document.getElementById('subsystem').textContent = '-';
        document.getElementById('compilationTime').textContent = '-';
        document.getElementById('sectionsCount').textContent = '-';
        document.getElementById('importTable').textContent = '-';
        document.getElementById('suspiciousIndicators').textContent = '-';
        dosHeader.innerHTML = '';
        ntHeaders.innerHTML = '';
        sectionHeaders.innerHTML = '';
    }

    // Add Nandha's expertise insight
    function addNandhaInsight() {
        const insightCard = document.querySelector('.insight-item');
        if (insightCard) {
            insightCard.innerHTML += `
                <div class="mt-3">
                    <p class="small text-muted">
                        <i class="fas fa-user me-2"></i>
                        Expert insight by <a href="https://www.linkedin.com/in/nandha-kumar-m-952342159/" target="_blank">Nandha Kumar M</a>
                    </p>
                </div>
            `;
        }
    }

    // Initialize Nandha's insight
    addNandhaInsight();
});