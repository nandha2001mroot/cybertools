document.addEventListener('DOMContentLoaded', function() {
    const elfFileUpload = document.getElementById('elfFileUpload');
    const inspectELF = document.getElementById('inspectELF');
    const clearAll = document.getElementById('clearAll');
    const elfHeader = document.getElementById('elfHeader');
    const programHeaderTable = document.getElementById('programHeaderTable');
    const dynamicSection = document.getElementById('dynamicSection');

    // Inspect ELF
    inspectELF.addEventListener('click', function() {
        const file = elfFileUpload.files[0];
        
        if (!file) {
            alert('Please upload an ELF file to inspect.');
            return;
        }

        inspectELFFile(file);
    });

    // Clear all
    clearAll.addEventListener('click', function() {
        elfFileUpload.value = '';
        clearResults();
    });

    // Inspect ELF file
    function inspectELFFile(file) {
        // Display file information
        document.getElementById('fileName').textContent = file.name;
        document.getElementById('fileSize').textContent = formatFileSize(file.size);
        document.getElementById('architecture').textContent = 'Inspecting...';
        document.getElementById('fileType').textContent = 'Inspecting...';

        // Simulate ELF inspection
        setTimeout(function() {
            // In a real implementation, you would parse the ELF file
            // For demonstration, we'll simulate results
            const architecture = getRandomArchitecture();
            const fileType = getRandomFileType();
            const entryPoint = getRandomEntryPoint();
            const programHeaders = getRandomProgramHeadersCount();
            const sections = getRandomSectionsCount();

            document.getElementById('architecture').textContent = architecture;
            document.getElementById('fileType').textContent = fileType;
            document.getElementById('entryPoint').textContent = entryPoint;
            document.getElementById('programHeaders').textContent = programHeaders;
            document.getElementById('sectionHeadersCount').textContent = sections;

            // Display suspicious indicators
            const indicators = getSuspiciousIndicators(fileType, sections);
            document.getElementById('suspiciousIndicators').textContent = indicators;

            // Generate mock ELF header
            elfHeader.innerHTML = '';
            const elfFields = [
                { field: 'e_ident', offset: '0x00', value: '0x7F454C46', description: 'ELF Magic' },
                { field: 'e_type', offset: '0x10', value: fileType.includes('Executable') ? '0x0002' : '0x0001', description: 'File Type' },
                { field: 'e_machine', offset: '0x12', value: architecture.includes('64') ? '0x003E' : '0x0003', description: 'Target Machine' },
                { field: 'e_version', offset: '0x14', value: '0x00000001', description: 'ELF Version' },
                { field: 'e_entry', offset: '0x18', value: entryPoint, description: 'Entry Point' }
            ];

            elfFields.forEach(field => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${field.field}</td>
                    <td>${field.offset}</td>
                    <td>${field.value}</td>
                    <td>${field.description}</td>
                `;
                elfHeader.appendChild(row);
            });

            // Generate mock program headers
            programHeaderTable.innerHTML = '';
            const programHeadersData = generateMockProgramHeaders(programHeaders);
            
            programHeadersData.forEach(header => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${header.type}</td>
                    <td>${header.offset}</td>
                    <td>${header.virtAddr}</td>
                    <td>${header.physAddr}</td>
                    <td>${header.fileSiz}</td>
                    <td>${header.memSiz}</td>
                    <td>${header.flags}</td>
                    <td>${header.align}</td>
                `;
                programHeaderTable.appendChild(row);
            });

            // Generate mock dynamic section
            dynamicSection.innerHTML = '';
            const dynamicEntries = generateMockDynamicSection();
            
            dynamicEntries.forEach(entry => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${entry.tag}</td>
                    <td>${entry.value}</td>
                    <td>${entry.description}</td>
                `;
                dynamicSection.appendChild(row);
            });
        }, 2000);
    }

    // Format file size
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Get random architecture
    function getRandomArchitecture() {
        const archs = ['x86 (32-bit)', 'x64 (64-bit)', 'ARM', 'ARM64', 'MIPS'];
        return archs[Math.floor(Math.random() * archs.length)];
    }

    // Get random file type
    function getRandomFileType() {
        const types = ['Executable', 'Shared Object', 'Relocatable'];
        return types[Math.floor(Math.random() * types.length)];
    }

    // Get random entry point
    function getRandomEntryPoint() {
        return '0x' + (Math.floor(Math.random() * 0x100000) + 0x400000).toString(16);
    }

    // Get random program headers count
    function getRandomProgramHeadersCount() {
        return Math.floor(Math.random() * 8) + 3; // 3-10 headers
    }

    // Get random sections count
    function getRandomSectionsCount() {
        return Math.floor(Math.random() * 15) + 5; // 5-20 sections
    }

    // Get suspicious indicators
    function getSuspiciousIndicators(fileType, sections) {
        const indicators = [];
        if (fileType === 'Executable' && sections > 10) {
            indicators.push('Large section count');
        }
        if (Math.random() > 0.8) {
            indicators.push('RWX segments');
        }
        return indicators.length > 0 ? indicators.join(', ') : 'None detected';
    }

    // Generate mock program headers
    function generateMockProgramHeaders(count) {
        const headers = [];
        const types = ['PT_LOAD', 'PT_DYNAMIC', 'PT_INTERP', 'PT_NOTE', 'PT_PHDR'];
        
        for (let i = 0; i < count; i++) {
            const type = types[Math.floor(Math.random() * types.length)];
            headers.push({
                type: type,
                offset: '0x' + (i * 0x1000).toString(16),
                virtAddr: '0x' + (0x400000 + i * 0x1000).toString(16),
                physAddr: '0x' + (0x400000 + i * 0x1000).toString(16),
                fileSiz: '0x' + (Math.floor(Math.random() * 0x10000)).toString(16),
                memSiz: '0x' + (Math.floor(Math.random() * 0x10000)).toString(16),
                flags: getRandomFlags(),
                align: '0x1000'
            });
        }
        
        return headers;
    }

    // Get random flags
    function getRandomFlags() {
        const flags = ['R', 'W', 'X'];
        const selected = [];
        for (let i = 0; i < 2; i++) {
            const idx = Math.floor(Math.random() * flags.length);
            if (!selected.includes(flags[idx])) {
                selected.push(flags[idx]);
            }
        }
        return selected.join('');
    }

    // Generate mock dynamic section
    function generateMockDynamicSection() {
        return [
            { tag: 'DT_NEEDED', value: 'libc.so.6', description: 'Needed library' },
            { tag: 'DT_STRTAB', value: '0x00400238', description: 'String table address' },
            { tag: 'DT_SYMTAB', value: '0x00400258', description: 'Symbol table address' },
            { tag: 'DT_RELA', value: '0x004002a8', description: 'Relocation table address' },
            { tag: 'DT_RELASZ', value: '0x00000018', description: 'Relocation table size' }
        ];
    }

    // Clear results
    function clearResults() {
        document.getElementById('fileName').textContent = '-';
        document.getElementById('fileSize').textContent = '-';
        document.getElementById('architecture').textContent = '-';
        document.getElementById('fileType').textContent = '-';
        document.getElementById('entryPoint').textContent = '-';
        document.getElementById('programHeaders').textContent = '-';
        document.getElementById('sectionHeadersCount').textContent = '-';
        document.getElementById('suspiciousIndicators').textContent = '-';
        elfHeader.innerHTML = '';
        programHeaderTable.innerHTML = '';
        dynamicSection.innerHTML = '';
    }

    // Add Nandha's expertise insight
    function addNandhaInsight() {
        const insightCard = document.querySelector('.insight-item');
        if (insightCard) {
            insightCard.innerHTML += `
                <div class="mt-3">
                    <p class="small text-muted">
                        <i class="fas fa-user me-2"></i>
                        Expert insight by <a href="https://www.linkedin.com/in/nandha-kumar-m-952342159/" target="_blank">Nandha Kumar M</a>
                    </p>
                </div>
            `;
        }
    }

    // Initialize Nandha's insight
    addNandhaInsight();
});